<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Split</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.51.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script src=sounds.js></script>
<script src=game.js></script>
<script type="text/javascript">
    
const WIDTH = 84
const HEIGHT = 48

const LIGHT = Phaser.Display.Color.HexStringToColor("#c7f0d8").color;
const DARK = Phaser.Display.Color.HexStringToColor("#43523d").color;

var config = {
    type: Phaser.AUTO,
    width: WIDTH,
    height: HEIGHT,
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 0 },
            debug: false,
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    },
    pixelArt: true,
    zoom: 8
};

var cursors;
var score = 0;
var scoreText;

var bg_image;
var fg_image;
    
const FPS = 30;
var total_elapsed_time = 0;
var total_ticks = -1;

var game = new Phaser.Game(config);
var sounds = new SoundManager();
var player_line;    // PlayerLine
var game_area;      // GameArea
var active_level;   // ParticleSet
    
// background images
const BG_DARK = 'bg_dark';
const BG_LIGHT = 'bg_light';
const BG_TITLE = 'bg_title';
const FG_TUTORIAL_1 = 'fg_tutorial_1';
const FG_TUTORIAL_2 = 'fg_tutorial_2';
const FG_LIVES = ['fg_lives_0', 'fg_lives_1', 'fg_lives_2', 'fg_lives_3', 'fg_lives_4',
                  'fg_lives_5', 'fg_lives_6', 'fg_lives_7', 'fg_lives_8'];
const FG_BLANK = 'fg_blank';

// object images
const PARTICLES_SHEET_LIGHT = 'particles_light';
const PARTICLES_SHEET_DARK = 'particles_dark';

// anims
const PARTICLE_ANIMS = []
    
// game states
const STATE_TITLE_ANIMATED = 0;
const STATE_TITLE_STATIC = 1;
const STATE_TUTORIAL = 2;
const STATE_PLAYING_LEVEL = 3;
const STATE_LOCKED_IN_ANIMATION = 4;
const STATE_GAME_OVER = 5;
const STATE_CREDITS = 6;
    
// game state vars
var cur_state;
var next_state = null;
var state_ticks = 0;

// input variables
var left_pressed = false;
var left_held = false;
var right_pressed = false;
var right_held = false;
var enter_pressed = false;
var reset_pressed = false;
    
// other variables

    
    
function preload () {
    this.load.image(BG_DARK, 'assets/bg_dark.png');
    this.load.image(BG_LIGHT, 'assets/bg_light.png');
    this.load.image(FG_TUTORIAL_1, 'assets/fg_tutorial.png');
    this.load.image(FG_TUTORIAL_2, 'assets/fg_tutorial_2.png');
    this.load.image(BG_TITLE, 'assets/bg_title.png');
    this.load.image(FG_BLANK, 'assets/fg_blank.png');
    var i;
    for (i = 0; i < FG_LIVES.length; i++) {
      this.load.image(FG_LIVES[i], 'assets/' + FG_LIVES[i] + '.png')
    } 
    this.load.spritesheet(PARTICLES_SHEET_LIGHT, 'assets/particles.png', { frameWidth: 4, frameHeight: 4 });
    this.load.spritesheet(PARTICLES_SHEET_DARK, 'assets/particles_inverted.png', { frameWidth: 4, frameHeight: 4 });
    
    sounds.load_sounds(this);
}

function create () {
    bg_image = this.add.image(WIDTH / 2, HEIGHT / 2, BG_DARK);
    fg_image = this.add.image(WIDTH / 2, HEIGHT / 2, FG_BLANK);
    fg_image.setDepth(1000);
    create_particle_anims(this);

    this.input.keyboard.on('keyup', anyKeyUp, this);
    this.input.keyboard.on('keydown', anyKeyDown, this);
    
    reset(this);
}

function create_particle_anims(scene) {
    var size = 4;
    var xdims = 21;
    var ydims = 12;
    var i;
    for (i = 0; i < 9; i++) {
        var light_key = 'particle_light_' + i;
        var dark_key = 'particle_dark_' + i;
        var start_frame = i * xdims;
        var n_frames = 4;
        if (i == 5) {
            n_frames = 6;
        } 
        var frames = [];
        var light_frames = [];
        var j;
        for (j = start_frame; j < start_frame + n_frames; j++) {
            frames.push(j);
        }
        PARTICLE_ANIMS.push(frames);
    }
}

function anyKeyUp (event) {
    if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.RIGHT 
            || event.keyCode === Phaser.Input.Keyboard.KeyCodes.D) {
        right_held = false;
    }
    if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.LEFT 
            || event.keyCode === Phaser.Input.Keyboard.KeyCodes.A) {
        left_held = false;
    }
}

function anyKeyDown (event) {
    if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.RIGHT 
            || event.keyCode === Phaser.Input.Keyboard.KeyCodes.D) {
        right_held = true;
        right_pressed = true;
    }
    if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.LEFT 
            || event.keyCode === Phaser.Input.Keyboard.KeyCodes.A) {
        left_held = true;
        left_pressed = true;
    }
    if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.ENTER 
            || event.keyCode === Phaser.Input.Keyboard.KeyCodes.SPACE) {
        enter_pressed = true;
    }
    if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.R) {
        reset_pressed = true;
    }
    sounds.play(game, sounds.all_sound_keys[rand_int(0, sounds.all_sound_keys.length)]);
}

function update (time, delay) {
    total_elapsed_time += delay
    var old_tick = total_ticks
    total_ticks = Math.floor(total_elapsed_time * FPS / 1000);
    
    if (total_ticks > old_tick) {
        real_update(this);
        
        right_pressed = false;
        left_pressed = false;
        enter_pressed = false;
        reset_pressed = false;
    }
}

function rand_int(min_inclusive, max_exclusive) {
   return min_inclusive + Math.floor(Math.random() * (max_exclusive - min_inclusive)) 
}

function set_bg(scene, bg_image_id, fg_image_id) {
    bg_image.setTexture(bg_image_id);
    fg_image.setTexture(fg_image_id);
}

function reset (scene) {
    next_state = STATE_TITLE_ANIMATED;
    if (player_line != null) {
        player_line.destroy(scene);
    }
    game_area = new GameArea(2, 2, 80, 30);
    player_line = new PlayerLine(game_area);
    if (active_level != null) {
        active_level.destroy(scene);
    }
    active_level = gen_level(game_area, 0);
}
    
function real_update (scene) {
    if (next_state != null) {
        cur_state = next_state;
        state_ticks = 0;
        next_state = null;
    }
    if (reset_pressed) {
        console.log("INFO: user requested a reset!");
        reset(scene);
    } else {
        switch (cur_state){
            case STATE_TITLE_ANIMATED:
                update_animated_title_state(scene); break;
            case STATE_TITLE_STATIC:
                update_static_title_state(scene); break;
            case STATE_PLAYING_LEVEL:
                update_playing_level_state(scene); break;
            default:
                console.log("WARN: unrecognized state: " + cur_state);
                reset(scene);
        }
    }
    state_ticks++;
}

function update_animated_title_state (scene) {
    set_bg(scene, BG_TITLE);
    if (enter_pressed) {
        next_state = STATE_TITLE_STATIC;
    }
}       

function update_static_title_state (scene) {
    set_bg(scene, BG_DARK, FG_TUTORIAL_1);
    if (enter_pressed) {
        next_state = STATE_PLAYING_LEVEL;
    }
}

function update_playing_level_state(scene) {
    set_bg(scene, BG_DARK, FG_LIVES[8]);
    player_line.rotate(0.1);
    player_line.update(scene, state_ticks);
    active_level.update(scene, state_ticks);
    
}

</script>

</body>
</html>
