<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Split</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.51.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script src=sounds.js></script>
<script src=game.js></script>
<script type="text/javascript">
    
const WIDTH = 84
const HEIGHT = 48

const LIGHT = Phaser.Display.Color.HexStringToColor("#c7f0d8").color;
const DARK = Phaser.Display.Color.HexStringToColor("#43523d").color;

var config = {
    type: Phaser.AUTO,
    width: WIDTH,
    height: HEIGHT,
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 0 },
            debug: false,
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    },
    pixelArt: true,
    zoom: 8
};

var cursors;
var score = 0;
var scoreText;

var bg_image;
var fg_image;
    
const FPS = 30;
const rotate_speed = 0.1;
const slow_rotate_speed = rotate_speed / 4;
var total_elapsed_time = 0;
var total_ticks = -1;

var game = new Phaser.Game(config);
var sounds = new SoundManager();
var player_line;    // PlayerLine
var game_area;      // GameArea
var active_level;   // ParticleSet
    
// background images
const BG_DARK = 'bg_dark';
const BG_LIGHT = 'bg_light';
const FG_TITLE = 'fg_title';
const FG_TUTORIAL_1 = 'fg_tutorial_1';
const FG_TUTORIAL_2 = 'fg_tutorial_2';
const FG_LIVES = ['fg_lives_0', 'fg_lives_1', 'fg_lives_2', 'fg_lives_3', 'fg_lives_4',
                  'fg_lives_5', 'fg_lives_6', 'fg_lives_7', 'fg_lives_8'];
const FG_BLANK = 'fg_blank';
const FG_GAME_OVER = 'fg_game_over';

// object images
const PARTICLES_SHEET_LIGHT = 'particles_light';
const PARTICLES_SHEET_DARK = 'particles_dark';

// anims
const PARTICLE_ANIMS = []
    
// game states
const STATE_TITLE_ANIMATED = 0;
const STATE_TITLE_STATIC = 1;
const STATE_TUTORIAL = 2;
const STATE_GENERATING_LEVEL = 3;
const STATE_PLAYING_LEVEL = 4;
const STATE_LOCKED_IN_ANIMATION = 5;
const STATE_GAME_OVER = 6;
const STATE_CREDITS = 7;
    
// game state vars
var cur_state;
var next_state = null;
var state_ticks = 0;

// input variables
var left_pressed = false;
var left_held = false;
var right_pressed = false;
var right_held = false;
var enter_pressed = false;
var reset_pressed = false;
var shift_held = false;
    
// other variables
var lives;
var level_num;
    
    
function preload () {
    this.load.image(BG_DARK, 'assets/bg_dark.png');
    this.load.image(BG_LIGHT, 'assets/bg_light.png');
    this.load.image(FG_TUTORIAL_1, 'assets/fg_tutorial.png');
    this.load.image(FG_TUTORIAL_2, 'assets/fg_tutorial_2.png');
    this.load.image(FG_TITLE, 'assets/fg_title.png');
    this.load.image(FG_GAME_OVER, 'assets/fg_game_over.png');
    this.load.image(FG_BLANK, 'assets/fg_blank.png');
    var i;
    for (i = 0; i < FG_LIVES.length; i++) {
      this.load.image(FG_LIVES[i], 'assets/' + FG_LIVES[i] + '.png')
    } 
    this.load.spritesheet(PARTICLES_SHEET_LIGHT, 'assets/particles.png', { frameWidth: 4, frameHeight: 4 });
    this.load.spritesheet(PARTICLES_SHEET_DARK, 'assets/particles_inverted.png', { frameWidth: 4, frameHeight: 4 });
    
    sounds.load_sounds(this);
}

function create () {
    bg_image = this.add.image(WIDTH / 2, HEIGHT / 2, BG_DARK);
    fg_image = this.add.image(WIDTH / 2, HEIGHT / 2, FG_BLANK);
    fg_image.setDepth(1000);
    create_particle_anims(this);

    this.input.keyboard.on('keyup', anyKeyUp, this);
    this.input.keyboard.on('keydown', anyKeyDown, this);
    
    reset(this);
}

function create_particle_anims(scene) {
    var size = 4;
    var xdims = 21;
    var ydims = 12;
    var i;
    for (i = 0; i < 9; i++) {
        var light_key = 'particle_light_' + i;
        var dark_key = 'particle_dark_' + i;
        var start_frame = i * xdims;
        var n_frames = 4;
        if (i == 5) {
            n_frames = 6;
        } 
        var frames = [];
        var light_frames = [];
        var j;
        for (j = start_frame; j < start_frame + n_frames; j++) {
            frames.push(j);
        }
        PARTICLE_ANIMS.push(frames);
    }
}

function anyKeyUp (event) {
    if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.RIGHT 
            || event.keyCode === Phaser.Input.Keyboard.KeyCodes.D) {
        right_held = false;
    }
    if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.LEFT 
            || event.keyCode === Phaser.Input.Keyboard.KeyCodes.A) {
        left_held = false;
    }
    if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.SHIFT) {
        shift_held = false;
    }
}

function anyKeyDown (event) {
    if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.RIGHT 
            || event.keyCode === Phaser.Input.Keyboard.KeyCodes.D) {
        right_held = true;
        right_pressed = true;
    }
    if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.LEFT 
            || event.keyCode === Phaser.Input.Keyboard.KeyCodes.A) {
        left_held = true;
        left_pressed = true;
    }
    if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.ENTER 
            || event.keyCode === Phaser.Input.Keyboard.KeyCodes.SPACE) {
        enter_pressed = true;
    }
    if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.R) {
        reset_pressed = true;
    }
    if (event.keyCode === Phaser.Input.Keyboard.KeyCodes.SHIFT) {
        shift_held = true;
    }
    sounds.play(game, sounds.all_sound_keys[rand_int(0, sounds.all_sound_keys.length)]);
}

function update (time, delay) {
    total_elapsed_time += delay
    var old_tick = total_ticks
    total_ticks = Math.floor(total_elapsed_time * FPS / 1000);
    
    if (total_ticks > old_tick) {
        real_update(this);
        
        right_pressed = false;
        left_pressed = false;
        enter_pressed = false;
        reset_pressed = false;
    }
}

function rand_int(min_inclusive, max_exclusive) {
   return min_inclusive + Math.floor(Math.random() * (max_exclusive - min_inclusive)) 
}

function set_bg(scene, bg_image_id, fg_image_id) {
    bg_image.setTexture(bg_image_id);
    fg_image.setTexture(fg_image_id);
}

function reset (scene) {
    next_state = STATE_TITLE_ANIMATED;
    if (player_line != null) {
        player_line.destroy(scene);
    }
    game_area = new GameArea(2, 2, 80, 30);
    player_line = new PlayerLine(game_area);
    if (active_level != null) {
        active_level.destroy(scene);
        active_level = null;
    }
    lives = 8;
    level_num = 0;
}
    
function real_update (scene) {
    if (next_state != null) {
        cur_state = next_state;
        state_ticks = 0;
        next_state = null;
    }
    if (reset_pressed) {
        console.log("INFO: user requested a reset!");
        reset(scene);
    } else {
        switch (cur_state){
            case STATE_TITLE_ANIMATED:
                update_animated_title_state(scene); break;
            case STATE_TITLE_STATIC:
                update_static_title_state(scene); break;
            case STATE_TUTORIAL:
                update_tutorial_state(scene); break;
            case STATE_GENERATING_LEVEL:
                update_generating_level_state(scene); break;
            case STATE_PLAYING_LEVEL:
                update_playing_level_state(scene); break;
            case STATE_LOCKED_IN_ANIMATION:
                update_locked_in_animation_state(scene); break;
            case STATE_GAME_OVER:
                update_game_over_state(scene); break;
            default:
                console.log("WARN: unrecognized state: " + cur_state);
                reset(scene);
        }
    }
    state_ticks++;
}

function update_animated_title_state (scene) {
    set_bg(scene, BG_LIGHT, FG_TITLE);
    
    if (enter_pressed) {
        next_state = STATE_TITLE_STATIC;
    }
}       

function update_static_title_state (scene) {
    set_bg(scene, BG_LIGHT, FG_TITLE);
    
    if (enter_pressed) {
        next_state = STATE_TUTORIAL;
    }
}

function update_tutorial_state (scene) {
    set_bg(scene, BG_DARK, FG_TUTORIAL_1);
    
    update_player_line(scene);
    
    if (enter_pressed) {
        next_state = STATE_GENERATING_LEVEL;
    }
}

function get_level_fg () {
    if (level_num == 0) {
        return FG_TUTORIAL_2;
    } else {
        return FG_LIVES[lives];
    }
} 

function update_generating_level_state (scene) {
    set_bg(scene, BG_DARK, get_level_fg());
    if (active_level != null) {
        active_level.destroy(scene);
    }
    active_level = gen_level(game_area, level_num);
    
    next_state = STATE_PLAYING_LEVEL;
}

function update_player_line(scene) {
    var rot_dir = 0;
    if (left_held) {
        rot_dir -= 1;
    }
    if (right_held) {
        rot_dir += 1;
    }
    var rot = rot_dir * (shift_held ? slow_rotate_speed : rotate_speed); 
    player_line.rotate(rot);
    player_line.update(scene, state_ticks);
}

function update_playing_level_state (scene) {
    set_bg(scene, BG_DARK, get_level_fg());
    
    if (enter_pressed) {
        next_state = STATE_LOCKED_IN_ANIMATION;
    } else {
        update_player_line(scene);
        
        var pts_on_line = active_level.get_points(player_line, 0);
        active_level.forEach(function (item, index) {
            if (pts_on_line.includes(item)) {
                item.set_is_light(false);
            } else {
                item.set_is_light(true);
            }
        })
        
        active_level.update(scene, state_ticks);
    }
}

function update_locked_in_animation_state (scene) {
    set_bg(scene, BG_DARK, FG_LIVES[lives]);
    
    var above = active_level.get_points(player_line, 1);
    var on_line = active_level.get_points(player_line, 0);
    var below = active_level.get_points(player_line, -1);
    
    while (on_line.length > 0) {
        var pt = on_line.pop();
        if (above.length < below.length) {
            above.push(pt);
        } else {
            below.push(pt);
        }
    }
    
    var score = Math.abs(above.length - below.length);
    console.log('INFO: score = ' + score);
    
    if (score > 0) {
        var lives_lost = Math.ceil(score / 2);
        lives = Math.max(0, lives - lives_lost);
    }
    
    if (lives > 0) {
        level_num += 1;
        next_state = STATE_GENERATING_LEVEL;
    } else {
        next_state = STATE_GAME_OVER;
    }
}

function update_game_over_state (scene) {
    set_bg(scene, BG_LIGHT, FG_GAME_OVER);  // TODO
    active_level.destroy();
    player_line.destroy();
    
    console.log('INFO game over! level: ' + level_num);
    
    if (enter_pressed) {
        reset(scene);
    }
}

</script>

</body>
</html>
